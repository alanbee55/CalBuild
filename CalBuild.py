import argparse
import sys
import re
import os

def GenerateTable(output_file, AnalogInput, DisplayValue, N2k, GraphicIndex, Comments):

#  output_file  object pointer to a file open for writing
#  DisplayValue  256 element list of 4 character strings
#  N2k  256 element list of byte values 
#  GraphicIndex = 256 element list of byte values
#  Comments list of strings used as comments.  Will be used until exhausted 

#  Output Header

	table_base = format( 0x0800 + AnalogInput * 2048, 'X')
	Header = '[TABLE]['+table_base.zfill(4)+'][8][256]\n'
	output_file.write(Header)

	
	for index in range(0 , 256):
		table_line = "db '"+ DisplayValue[index] + format(N2k[index], 'X').zfill(2) + \
		format(GraphicIndex[index] , 'X').zfill(2) + "';" 
		if len(Comments) != 0:
			table_line += Comments[0]
			Comments.pop(0)
		output_file.write(table_line + '\n')
		
#  Range checking functions

#  Analog Channel (as command line arguement

def ChannelCheck (string):
	if AnalogInputRangeCheck(string):
		return int(string)
	raise argparse.ArgumentTypeError('Analog input channel out of range')
	
# output range check for fixed output
	
def FixedRangeCheck (string):
	value = int(string)
	if value < 0 or value > 255 :
		raise argparse.ArgumentTypeError('Fixed value not between 0 - 255')
	return value

# Analog channel range helper function 

def AnalogInputRangeCheck (string) :
	value = int(string)
	if value < 0 or value > 11 :
		return False
	else:
		return True
		
def ProcessPointDictionary(pointsDict, pointsList) :
# does the rise/run magic 
# input dictionary has to have end points key values, guarenteing a point pair

	first_point = -1
	
	for index  in sorted(pointsDict):
		second_point = index
		if first_point == -1 :
			first_point = index
			pointsList.append(pointsDict[index])
			continue
			
# have a point pair here
		outstring = 'point pair  ' + str(first_point) + ' ,  ' + str(second_point)
#		print(outstring)
		delta = float(pointsDict[second_point] - pointsDict[first_point]) /  \
		float(second_point - first_point)
		
		pointsList.pop()
# pop last item

		for pointer in range(first_point , second_point + 1 ):
			y_val = int(delta * float(pointer - first_point) + pointsDict[first_point])
			pointsList.append(y_val)
#			outstring = ' pointer ' + str(pointer) + ' y value ' +  str(y_val) + \
#			' pointslist length: ' + str(len(pointsList))
			 
#			print(outstring)
		prev_first_point = first_point
		first_point = second_point
# 
		
#	print('process list complete')
	
			

	

# Main routine 

parser = argparse.ArgumentParser(description='Build a Chetco calibration table')
group = parser.add_mutually_exclusive_group(required=True)
group.add_argument('infile', nargs='?', type=argparse.FileType('r'), 
					help='Configuration file, required unless -f specified')

group.add_argument('-f', nargs=1, type=FixedRangeCheck, dest='fixed',
					help='Generates a fixed output calibration table')
parser.add_argument('-o', nargs='?', type=argparse.FileType('w'), dest='outfile',
					default=sys.stdout,
					help='direct output table to the specified file  default: sysout')
parser.add_argument('-a', nargs=1, type=ChannelCheck, dest='analog_channel',
					default=[0],
					help=' Sets table address for specified analog channel')
parser.add_argument('--index', action="store_true", 
					help='  Display Values to be set to linear text')
					

args = parser.parse_args()

Version = "1.0"

#  Parm checks  

# argparse did it all (almost)

if args.outfile is None:
	print(' -o flag used but no output file specified')
	exit()
	

# Table objects

DisplayValue = []
N2k = []
GraphicIndex = []
Comments = []
FunctionString = '' 

DisplayValueDict = {}
N2kDict = {}
GraphicIndexDict = {}


AnalogInput = args.analog_channel[0]

# build correct filter  function based on index flag 

if args.index :

	filter_function = """
def DisplayValueGenerate(index, n2k, graphicsIndex): 

	return (str(index).rjust(4))
   """
else: 

	filter_function = """
def DisplayValueGenerate(index, n2k, graphicsIndex): 
	return('    ')
   """
   
exec(filter_function)



if (args.fixed is not None):
# fixed case

# generate filter function 



	fixed_val = args.fixed[0]
	for index in range(0 , 256):
		N2k.append(fixed_val)
		GraphicIndex.append(fixed_val)
		DisplayValue.append(DisplayValueGenerate(index, fixed_val, fixed_val))
		
	Comments.append('  Configuration Table generated by CalBuild version '+Version)
	Comments.append('  Fixed value: '+ str(fixed_val))
	Comments.append('  Analog input: ' + str(AnalogInput))
	Comments.append('  Index:  ' + str(args.index))
	
	
	GenerateTable(args.outfile, AnalogInput, DisplayValue, N2k, GraphicIndex, Comments)
	exit()
		

# process config file here 

# Default endpoints

N2kDict[0] = 0
N2kDict[255] = 255



GraphicIndexDict[0] = 0
GraphicIndexDict[255] = 255



ConfigFileList = args.infile.readlines()

#use regular expressions to parse the file

for ConfigLine in ConfigFileList:

	
# blank line

	Command = re.match( r'^\s*$' , ConfigLine, re.M|re.I)
	if Command :
		continue
		
# Comments
	
	Command = re.match(r'#(.*)' , ConfigLine, re.M|re.I)
	if Command:
		  Comments.append(' ' + Command.group(1).rstrip())
		  continue
		  
# Analog input 
		  
	Command = re.match(r'\s*Analog Input \s*(\d+)' , ConfigLine, re.M|re.I)
	if Command:
		if not AnalogInputRangeCheck(Command.group(1)):
			outstring = 'Error; Analog input of '  + Command.group(1) + \
			' is out of range... exiting'
			print(outstring)
			exit()
		AnalogInput = int(Command.group(1))
		
		continue

#  n2k point 
		
	Command = re.match(r'\s*n2k\s*(\d+)\s*,\s*(\d+)' , ConfigLine , re.M|re.I)
	if Command:
		x_val = int(Command.group(1))
		y_val = int(Command.group(2))
#  validate arguments
		if x_val < 0 or x_val > 255 :
			print('Error: n2k parm x value: ' + str(x_val) + ' out of range.  exiting...')
			exit()
			
		if y_val < 0 or y_val > 255 :
			print('Error: n2k parm y value: ' + str(y_val) + ' out of range.  exiting... ')
			exit()	
			
		N2kDict[x_val] = y_val
		

		continue

# Graphic Display point  

	Command = re.match(r'\s*GraphicDisplay\s*(\d+)\s*,\s*(\d+)' , ConfigLine , re.M|re.I)
	if Command:
		x_val = int(Command.group(1))
		y_val = int(Command.group(2))
#  validate arguments
		if x_val < 0 or x_val > 255 :
			print('Error: Graphic Display parm x value: ' + str(x_val) + ' out of range.  exiting...')
			exit()
		if y_val < 0 or y_val > 255 :
			print('Error: Graphic Display parm y value: ' + str(y_val) + ' out of range.  exiting... ')
			exit()

		GraphicIndexDict[x_val] = y_val
		
	
		continue

# DisplayValue value

	Command = re.match(r"\s*DisplayValue\s*(\d+)\s*,\s*'(.{4})'" , ConfigLine , re.M|re.I)
	if Command:
		x_val = int(Command.group(1))
		disp_val = (Command.group(2))
#  validate arguments
		if x_val < 0 or x_val > 255 :
			print('Error: Display value x value: ' + str(x_val) + ' out of range.  exiting...')
			exit()
		
		DisplayValueDict[x_val] = disp_val
			
		continue

#  Build function 
	Command = re.match(r'Genfunction (.*)' , ConfigLine, re.M|re.I)
	if Command:
		function_line = Command.group(1).rstrip()
		FunctionString += function_line + '\n\r'
		
		continue		
		
# Line unrecognized 
		
	else:
		outstring = 'Line: ' + ConfigLine + 'Not recognized  skipping'
		print(outstring)
		
# config file processing complete

# Process the dictionaries into the list 


# process n2k   

ProcessPointDictionary(N2kDict, N2k)
ProcessPointDictionary(GraphicIndexDict, GraphicIndex)


# Generate display values

if FunctionString != '':
# redefine function 
	FunctionString = 'def DisplayValueGenerate(index, n2k, graphicsIndex):\r' + FunctionString
	
	exec(FunctionString)

for n in range(0 , 256):
	d_val = DisplayValueGenerate(n, N2k[n] , GraphicIndex[n])  
	DisplayValue.append( str(d_val).rjust(4))
	
# load with function value

for n in DisplayValueDict :
#  overlay with actuals
	DisplayValue[n] = DisplayValueDict[n]
	
# put in Comment Prolog 

if FunctionString != '': 
	Comments.insert(0, '  Display Value Generator detected')
else:
	Comments.insert(0, '   Index: ' + str(args.index))

Comments.insert(0 , '  Analog input: ' + str(AnalogInput))
Comments.insert(0 , ' ')
Comments.insert(0 , '  Config file name: ' + os.path.basename(args.infile.name))
Comments.insert(0 , '  Configuration Table generated by CalBuild version '+Version)


#  generate table

GenerateTable(args.outfile, AnalogInput, DisplayValue, N2k, GraphicIndex, Comments)

exit()




	